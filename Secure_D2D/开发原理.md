# 摘要

信息的传播不仅依赖发送接收双方协商的加密算法和密钥，更需要可靠的传送协议。本学期我们在简化的通信协议基础上，传递包含消息的音频。其中音频是由消息编码所产生的。发送方需要先将想发送的消息通过双方协定过的算法加密，然后编码成可以发送的稳定音频。接收方收到这一音频后，首先转换成被加密后的消息，然后再解密。经过验证，这种基于通信协议的加密消息编码音频传输具有稳定性。



# 背景

在二十一世纪的信息时代，计算机网络飞速发展，为了保证用户在网络、通信中的信息安全，信息加密技术的发展显得尤为重要。截止目前，已有多种类型的信息加密技术，例如基于对称加密的会话、基于公钥加密的点对点消息传输，基于DH算法的群组会话等。由于消息传输的普及性和必须性，选择可靠的传输方式显得尤为重要。

公钥加密方法已经被证明具有在加解密消息的会话传输中具有多种优点：它不仅依赖密钥的安全性，相较于对称加密哈希加密的加密方法，减少了计算性。在较低的计算量情况下，仍然保证一定程度的不被破解性。目前较为流行的公钥加密方法有：RSA，Elgamal，ECC。并且由它们产生的会话协商也具有高效性，如DH，ECDH。并且随着新的密码理论的产生，例如格密码学，量子密码学，公钥加密的可扩展性使其更好地和这种密码形成稳定的消息加解密传输系统。

但依靠密码学传输消息仍有弊端，比较流行的一种做法是音频消息的传输。我们把加密后的消息编码成音频，在发送方和接收方中传递并不是加密后的消息数据，而是编码后的音频。音频的传输也不仅仅是简单地直发直收，我们需要采取一定可靠的通信协议。这种通信协议是在D2D的基础上实现的。



# 设计方案

音频通信协议技术总体采用应答模式完成认证，发送方发送音频到接收方，接收方可以对数据进行处理，完成对数据的转换，并且得到发送方加密后的数据。

1、DH内部随机数产生，rsa内部参数产生：这一步是确定整个系统的参数

2、DH交换 ，key产生：接收方和发送方通过DH协商产生密钥key

3、公钥发送：发送方把自己的密钥发送给接收方

4、消息签名发送：其中消息体的格式为 明文+签名+签名长度+签名长度的长度（固定1位），所有传输用音频进行，以10个音频标志10个数，进行10进制传播，传播速率大约为 2.8bit /s

## 关键算法

**对称加密**

对称加密算法也叫传统密码算法（加密密钥算法、单钥算法），加密密钥能从解密密钥中推算出来。

发件人和收件人共同拥有同一个密钥，既用于加密也用于解密。对称密钥加密是加密大量数据的一种行之有效的方法。对称密钥加密有许多种算法，但所有这些算法都有一个共同的目的：将明文（未加密的数据）转换为密文。由于对称密钥加密在加密和解密时使用相同的密钥，所以这种加密过程的安全性取决于是否有未经授权的人获得了对称密钥。

衡量对称算法优劣的主要尺度是其密钥的长度。密钥越长，在找到解密数据所需的正确密钥之前必须测试的密钥数量就越多。需要测试的密钥越多，破解这种算法就越困难。有了好的加密算法和足够长的密钥，如果有人想在一段实际可行的时间内逆转转换过程，从密文中推导出明文，从应用的角度来讲，这种做法是徒劳的。

优缺点：

对称密钥的主要优点在于速度快，通常比非对称密钥快100倍以上，而且可以方便地通过硬件实现。

主要问题在于密钥的管理复杂。由于每个通信者间都需要一个不同的密钥，N个人通信需要=n（n-1）/2密钥；同时如何安全的共享加密密钥给需要解密的接受者成为最大的问题，并且由于没有签名机制因此也不能实现抗可抵赖问题，即通信双方都可以否认发送或接收过的信息

![image-20231204152112522](https://gitee.com/jia-huaiyu/images/raw/master/202312041521587.png)



**公钥加密**

非对称算法也叫公钥加密，使用两个密钥：一个公钥和一个私钥，这两个密钥在数学上是相关的。

在公钥加密中，公钥可在通信双方之间公开传递，或在公用储备库中发布，但相关的私钥是永远掌握在自己手里。只有使用私钥才能解密用公钥加密的数据。使用私钥加密的数据只能用公钥解密。

与对称密钥加密相似，公钥加密也有许多种算法替换另一种，而变化却不大，因为它们的工作方式是相同的。而不同公钥算法的工作方式却完全不同，因此它们不可互换。

公钥算法是复杂的数学方程式，使用十分大的数字。公钥算法的主要局限在于，这种加密形式的速度相对较低。实际上，通常仅在关键时刻才使用公钥算法，如在实体之间交换对称密钥时，或者在签署一封邮件的散列时（散列是通过应用一种单向数学函数获得的一个定长结果，对于数据而言，叫做散列算法）。

优缺点：

非对称密钥的主要优势在于密钥能够公开，由于用作加密的密钥（也称公开密钥）不同于作解密的密钥（也称私人密钥）因而解密密钥不能根据加密密钥推算出来，所以可以公开加密密钥。公钥加密提供了一种有效的方法，可用来把大量数据执行对称加密时使用的机密密钥发送给某人。私钥加密而用公钥解密，主要用于数字签名。

主要局限就是速度慢。实际上，通常仅在关键时刻才使用公钥算法，如在实体之间交换对称密钥时，或者在签署一封邮件的散列时（散列是通过应用一种单向数学函数获得一个定长结果，对于数据而言，叫做散列算法）

 

基于公钥的密钥交换步骤如下（数字信封的工作原理）：

1、发件人获得收件人的公钥

2、发件人创建一个随机密钥（在对称密钥加密中使用的单个密钥）

3、发件人使用密钥和对称密钥算法将明文数据转换为密文数据

4、发件人使用收件人的公钥将密钥转换为密文密钥

5、发件人将密文数据和密文密钥一起发给收件人

6、收件人使用其私钥将密文密钥转换为明文

7、收件人使用明文密钥将密文数据转换为明文数据。

![image-20231204152217239](https://gitee.com/jia-huaiyu/images/raw/master/202312041522280.png)

![image-20231204152229155](https://gitee.com/jia-huaiyu/images/raw/master/202312041522191.png)



**DES算法**

DES 的功能是：给定一个 64 位的明文和一个 64 位的密钥，输出一个 64 位的密文。这个密文可以用相同的密钥解密。所谓“64位的密钥”，其实里面只有54位在起作用。剩余的位可以直接丢弃，或者当作奇偶校验位。

虽然 DES 一次只能加密 8 个字节，但我们只需要把明文划分成每 8 个字节一组的块，就可以实现任意长度明文的加密。如果明文长度不是 8 个字节的倍数，还得进行填充。现在流行的填充方式是 PKCS7 / PKCS5，都是很简单的思路，用于把任意长度的文本填充成 8 字节的倍数长，也能方便地恢复原文。此外，独立地对每个块加密，最后直接拼起来是不行的。

加密流程：

![image-20231204152332228](https://gitee.com/jia-huaiyu/images/raw/master/202312041523265.png)

初始置换：初始置换是将原始明文经过IP置换表处理

生成子密钥：DES 加密共执行16次迭代，每次迭代过程的数据长度为48位，因此需要16个48位的子密钥来进行加密。

![image-20231204152356087](https://gitee.com/jia-huaiyu/images/raw/master/202312041523130.png)

迭代：

![image-20231204152634881](https://gitee.com/jia-huaiyu/images/raw/master/202312041526924.png)

逆置换：将初始置换进行16次的迭代，即进行16层的加密变换，得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。逆置换是初始置换的逆运算。



**RSA**

RSA加密算法是一种非对称加密算法。在RAS算法中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，由于无法计算出大数n的欧拉函数phi(N)，所以不能根据PK计算出SK。

也就是说，对极大整数做因数分解的难度决定了RSA算法的可靠性。理论上，只要其钥匙的长度n足够长，用RSA加密的信息实际上是不能被解破的。

RSA算法通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要。

 

实现步骤

生成大素数p和q，我们采取随机数生成的方法。首先随机生成p，q的位数a，然后传入随机生成的位数a，通过生成指定区间内的随机数b，并且判断这个数b是不是素数。如果是素数，那么就返回这个素数。如果不是，就继续生成随机数，直到生成的随机数是素数。

生成素数p和q后，由n=p*q，我们就得到了需要的密钥n，接着计算n的欧拉函数。欧拉函数是计算与n互质的数的个数，其中对于素数来说，有以下特别公式：$\phi(N)=(p-1)(q-1)$

生成特定的质数e，用来产生私钥d。e是一个和n的欧拉函数互质的质数，我们采取指定区间内随机数生成的方法。私钥d是逆元运算产生的，即求出e对n的欧拉函数的逆元。$ed\equiv 1(\mod \phi(N))$

加密运算：$c\equiv m^e(\mod n)$

解密运算：$m\equiv c^d(\mod n)$



**DH协商**

密钥安全性

在对称加密中，无论加密解密，通信双方都是使用相同的密钥，如果其中一方密钥泄露了，信息便会遭到破解。使用公开密钥双向加密可以极大提高安全性，通信双方手握对方的公钥进行信息加密，保留自己的私钥进行解密，从客户端发去的加密信息即使被中途截获，没有私钥的话也无法解密，而私钥保存在服务器端，相反一样。这样将密钥对分成公钥和私钥的方式，比起对称加密共同使用相同的密钥，明显更安全。无论是对称加密还是公开密钥，安全性关键都是在于密钥的长度，例如上一篇日志讲到的公开密钥，它是怎么生成公钥的？是两个大质数相乘后结果n，和随机数e组成的，如果要解出私钥，首先就要得到这两个大质数，可以通过对n进行因式分解，不过只要这两个大质数足够大，对其进行因式分解是十分困难的。

 

传输问题

在密钥本身的安全性得到保证后，还不够，因为密钥是要发送给通信对方的，如果在发送密钥的时候被截获，那么前面做的一切都是徒劳。通常一个服务器端会接收处理多个客户端，双方建立连接后，开始消息发送，为了保证信息安全性，会使用相应的加密措施，无论是对称加密害死公开密钥，都需要发送密钥给对方进行加密解密，那么在发送密钥过程中，怎么保证密钥安全不泄露？

如果只是几人十几人的小组内进行互相通信，那么可以简单地通过外部方式例如邮件方式传输密钥，而不在通信线路上传输。可是对于C/S模式下服务器端需处理许多的客户端连接，但是服务器端并不知道这些客户端来自谁，没有办法通过外部如邮件的方式发送密钥，只能就彼此建立的连接线路上进行通信，怎么把密钥安全地通过这条线路发送到客户端？

 

密钥协商算法

密钥协商算法可以解决上面提到的两个问题，生成安全的密钥，和安全的传输，还能解决密钥存储问题。密钥存储问题，简单来说，假如我们把密钥保存在本地磁盘中，每次加密解密都出本地获取密钥，那么就几乎没什么泄露的问题，但如果我们把密钥保存在是数据库中，数据库泄露便等于密钥泄露了。

会话密钥

上面说到，一个服务器端需要处理很多很多的客户端连接，如果我们为每一个连接都保存一个固定的不同的密钥，那么存储量将十分庞大，但是我们又不能让它们使用统一的密钥，这显然是不安全的，要解决这个问题，可以用到会话密钥的方式。会话密钥就是在本次通信中使用的一次性密钥，当通信结束后密钥就失效了，等下一次建立连接时会生成不同的会话密钥，会话密钥仅在本次通信期内有效。在我们访问https协议的网址，即https://开始的网址时，我们的浏览器会和服务器之间使用SSL/TLS协议进行加密通信，用到的就是会话密钥。会话密钥是存储在客户端和服务器端的内存中的，当通信结束后，会话密钥失效，便会从内存中丢弃，解决了上面的密钥存储问题。

DH密钥协商

DH（Diffie-Hellman）密钥协商的做法是让通信双方在通信上交换彼此的信息来共同计算出相同的会话密钥，即使中间一部分传递信息被截获，也无法根据其计算出会话密钥，因为计算会话密钥的另一部分信息在接收方处，而接收方并没有公开这部分信息，因此中间方并不会有足够的信息来得到会话密钥，进而破解之后的通信密文。

可以看到，通常由服务器端生成DH密钥文件参数，在客户端和服务器端建立连接后，密钥协商过程可以归纳为：

1.客户端发送请求DH参数，服务器端生成DH密钥文件参数，包括p，g，公钥spub和钥spri。$spub=g^{spri}\mod p$

2.服务器端发送参数p，g以及公钥spub给客户端，客户端接收后，先是自己生成一个私钥cpri，然后根据参数p，g，服务器端公钥spub和自己的私钥cpri计算得出客户端公钥cpub。$cpub=g^{cpri}\mod p$

3.客户端将公钥cpub发送给服务器端，服务器端根据客户端公钥cpub和自己的私钥spri计算得到会话密钥。$M=cpub^{spri}\mod p$

4.客户端根据私钥cpri和服务器端公钥spub计算得到会话密钥。密钥协商完成。$M=spub^{cpri}\mod p$

![image-20231204153412216](https://gitee.com/jia-huaiyu/images/raw/master/202312041534271.png)



## 详细代码

```java
		public void reciveRSAn()
	    {
	        BigInteger bigInteger = reciveVoice("RSAn.wav");
	        System.out.println("------------------");
	        System.out.println("接收到 " + bigInteger);
	        byte[] bytes = BigIntegerTobyte(bigInteger);
	        eitherRSAn=byteToBigInteger(DES.decrypt(bytes,DES.passwordToKey(KEY.toString())));
	        System.out.println("转码 " + eitherRSAn);
	        System.out.println("------------------");
	    }

```

在DH协商之后会生成DES加密的密钥，之后就需要协商公钥加密的密钥

1. 首先接收发送的音频信息，调用reciveVoice()将接收到的音频文件转为大整数

2. 将公钥的大整数数据类型通过BigIntegerTobyte（）转化为十六进制，便于通过DES.decrypt()解密

3. 通过将解密数据用byteTOBigInteger（）转为大整数得到十进制的大整数公钥



```java
	BigInteger messageToBig(String s)
	    {
	        BigInteger ans = BigInteger.ZERO;
	        for(int i=0;i<s.length();i++)
	        {
	            int tep;
	            if(s.charAt(i)>='0'&&s.charAt(i)<='9')
	                tep=s.charAt(i)-'0'+1;
	            else if(s.charAt(i)>='a'&&s.charAt(i)<='z')
	                tep=s.charAt(i)-'a'+11;
	            else if(s.charAt(i)>='A'&&s.charAt(i)<='Z')
                tep=s.charAt(i)-'A'+37;
	            else
	                tep=63;
	            ans=(ans.multiply(BigInteger.valueOf(64))).add(BigInteger.valueOf(tep));
	        }
	        for(int i=1;i<=40-s.length();i++)
            ans=ans.multiply(BigInteger.valueOf(64));
	        System.out.println("文本转化1 " + ans);
	        return ans;
	    }

```

明文消息是字符串类型，但是我们加密过程中需要的是数字类型的数据，所以我们规定了一个六十四进制，64进制是0-9 对应 1-10，a-z对应11-36 ， A-Z 对应37 - 62 ， 空格对应 63，完成了基本的字符串到数据的转化，然后通过循环遍历字符串，逐个判断并通过BigInteger类的内置函数进行计算。



```java
BigInteger Coding(BigInteger message)
	    {
	        String s1;
	        BigInteger sign=decode(message);
	        BigInteger temp =sign;
	        int num=0;
	        while(temp.compareTo(BigInteger.ZERO)==1){
	            num++;
	            temp=temp.divide(BigInteger.TEN);
	        }
        int nnum=0;
	        while (num>0)
	        {
	            nnum++;
	            num/=10;
	        }
	        s1= message.toString() + decode(message).toString() + num + nnum;
	        BigInteger ed = new BigInteger(s1);
	        return ed;
	    }

```

在明文转为我们加密可以使用的数据类型之后，我们需要对消息进行编码，使其包含发送方的数据签名，以完成身份认证，并在拼接过程中加入解码需要的数据，帮助接收方完成信息获取。

1.使用decode进行RSA的私钥加密，产生数据签名

2.计算签名长度和签名长度的长度（2位）

3.最后进行拼接返回最后的报文，送去加密传输。



```java
void reciveMessage()
	    {
	        BigInteger bigInteger = reciveVoice("Message.wav");
	        System.out.println("------------------");
	        byte[] bytes = BigIntegerTobyte(bigInteger);
	        BigInteger Message=byteToBigInteger(DES.decrypt(bytes,DES.passwordToKey(KEY.toString())));
	        int Messagecoutcout = (Message.mod((BigInteger.TEN))).intValue();
	        Message = Message.divide(BigInteger.TEN);
	        int Messagecout = (Message.mod((BigInteger.TEN).pow(Messagecoutcout))).intValue();
	        Message = Message.divide((BigInteger.TEN).pow(Messagecoutcout));
	        BigInteger sign = Message.mod((BigInteger.TEN).pow(Messagecout));
	        Message = Message.divide((BigInteger.TEN).pow(Messagecout));
	        System.out.println("提取明文 " + Message);
	        System.out.println("提取签名 " + sign);
	        if((eitherENcode(sign)).equals(Message))
            System.out.println("*** 签名正确 ***");
	        System.out.println("数字转化文本 " + BigIntegerToMessage(Message));
	        System.out.println("------------------");
	    }

```

1. 接收方首先通过reciveVoice（）接受音频文件，并根据音频协议，将音频文件转为大整数数据。

2. 将大整数数据通过BigIntegerTobyte（）转为十六进制数据。

3. 将十六进制数据通过DES解密获取到报文数据。

4. 根据报文数据中的签名长度和签名长度的长度对消息进行分割。

5. 对签名用DH协商后获取的RSA公钥进行eitherENcode（）解密

6. 将签名解密获取到的明文消息和分割获取的明文消息进行比较，若相同则可以表示身份认证成功，若不同则身份认证失败，将获取到的消息丢弃。



# 测试

通过了在开发主机中的音频传输。考虑到项目在音频传输的过程中一定会产生一定程度的误差，因此在开发主机中进行实际的音频传输是必要的。对于其中密码学的部分，考虑到密码学的精确性和稳定性，在非开发主机中进行测试将更为高效。

 

主体的开发策略为极限编程。整体的信息交换策略使用了较多的函数元件组，调用了较多的方法。因此采用此种策略来逐步开发，并且实时检测开发的结果的正确与否。

![image-20231204154142679](https://gitee.com/jia-huaiyu/images/raw/master/202312041541730.png)

考虑到开发过程中的函数大量嵌套，因此在每一个函数编写完毕后都会进行单元测试。单元测试一般采取由小数据像大数据逐步更换的方式。大数据测试的正确与否一般通过，先找到已经存在的正确的组件进行数据处理之后的结果与我们自己的数据处理结果进行比对来判断我们的数据是否正确。其次在对大数据进行精确测试之前我们还会进行一次逻辑测试，我们的数据处理一般为加解密，所以我们会将大数据先加密再解密比对前后数据是否一直来粗略的判断数据的正误。同时，也会出现大量的信息变形。验证这些变化后的信息的正确性的方式为使用已经成熟且确切可靠的单元来进行辅助测试。

 

  单元测试结束后的集成测试主要针对的试个各单元之间的数据传输是否有误，我们采取的方式是在数据传输之前手动确认数据是否有误。

 

  最后的应用测试我们采取了实景模拟的方式，我们找了未参与开发的主机安装jdk之后运行我们的项目来进行测试。其中的音频传输的环节采取真实的应用场景。为了确保对于音频的测试能达到目标要求，进行了对于不同场景之下的音频传输测试，确保了音频传输的可靠性。

![image-20231204154202547](https://gitee.com/jia-huaiyu/images/raw/master/202312041542627.png)

![image-20231204154209554](https://gitee.com/jia-huaiyu/images/raw/master/202312041542600.png)