# 背景描述

信息的加密与解密是一个复杂而又繁重的工作，它主要可分为两大类：对称加密与非对称加密。对称加密是指使用同一个密钥对信息进行加密和解密称为对称加密。它的优点是加密解密速度快，但同样也有缺点：相对不安全，由于双方使用的是同一个密钥进行加密解密，任何一方的密钥泄漏，整个加密解密过程就暴露了。因此，我们更倾向于非对称加密，即加密和解密使用不同的密钥。

在非对称密钥算法中,RSA算法是基础而富有扩展性的算法，它通过简单的数学运算实现了信息的加密与解密，具有一定的安全性。因此，我们本项目的任务就是要通过学习补充基础的数学知识，掌握理解RSA算法的原理与实现步骤，编写代码去实现RSA算法，并且程序处理能力可以达到RSA算法的商用级别（可加解密数据大约是二进制的1024位）。

| 种类       | 原理                               | 使用场景                               | 优点                                   | 缺点                                                         |
| ---------- | ---------------------------------- | -------------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 对称加密   | 使用同一个密钥对信息进行加密和解密 | A与B共同约定并存储一个密钥             | 加密解密速度快                         | 相对不安全，由于 AB 双方使用的是同一个密钥进行加密解密，任何一方的密钥泄漏，整个加密解密过程就暴露了 |
| 非对称加密 | 加密和解密使用不同的密钥           | B 生成一套公钥和私钥，并将公钥发送给 A | 相对安全，确保了传递消息的双方是AB本人 | 效率较为低下，加密解密的过程相对于对称加密较为缓慢           |



整个程序的设计流程图如下：

![image-20231204102012485](https://gitee.com/jia-huaiyu/images/raw/master/202312041020552.png)



# 设计方案

## 需要考虑的复杂问题

**RSA算法描述**

- 选取两个不相同的大素数$p,q$
- 计算$n=pq$和其欧拉函数$\phi (n) =(p-1)(q-1)$
- 选一整数$e,1<e<\phi (n)$，，使得$gcd(\phi (n), e)=1$
- 计算$d,ed\equiv 1\mod \phi (n)$
- $(n,e)$为公钥，$d$为私钥
- 加密：对于明文$m$, $c=E(m)=m^e\mod n$
- 解密：对于密文c，$m=D(c)=c^d\mod n$

RSA算法的正确性：$c^d\mod n=m^{ed}\mod n=m^{k\phi(n)+1}\mod n=m\mod n$

例如：p=7，q=17，n=119，$\phi(n)=(p-1)(q-1)=96$，e=5，d=77

公钥为$\{5,119\}$，私钥为$\{77,119\}$

明文m=19，$c=19^5\mod 119=66$

解密为$66^{77}\mod 119 =19$

**RSA算法的安全性**

RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明。 RSA的难度与大数分解难度等价。 因为没有证明破解RSA就一定需要做大数分解。 RSA算法的安全强度随着其密钥长度的增加而增加。因此，我们要确保密钥的位数，并且保证它的安全级别可以达到商用，那么密钥N至少是二进制下1024位（转换成十进制大概350位）。

**大整数的加减乘除运算方法**

为了能够确保RSA算法的安全性，我们要提高N的位数。在常见的商用RSA算法中，其计算数量级别大约在二进制下1024位。针对如此大数据的计算，我们主要有两种实现方法：采用手写高精度和python语言自带的高精度。手写高精度可以将大数当作数组来处理，python语言没有明确的整数范围，但可以知道的是它能够计算二进制1024位数据。为了提高代码的可读性与简介性，我们选择后者，用python自带的高精度。

**如何生成与检验大素数**

算法的安全性很大程度上依赖于数据，我们同样要确保程序数据的产生也具有一定的安全性，因此我们选择随机数生成的方法生成素数。素数p和q是很大的数，如何检验它是否是素数是一个难题。常见的检验素数的方法有暴力破解，费马小定理等，但它们的时间复杂度都很高，效率低下，当我们用这两种方法判断素数时会使得程序的运行时间大大增加，因此我们采用在费马小定理的基础上修改的的Miller-Rabin概率素性测试。

**如何提高加解密算法的运行效率**

在RSA算法的代码实现中，选择合适的算法提高运算效率是必要的。数的乘方是庞大的计算工作，我们选择快速幂的方法，在log复杂度下便可实现乘方。其次，对于信息的加密和解密，我们使用中国剩余定理与快速幂结合取代单一的快速幂的方法。



## 详细算法

生成大素数p和q，我们采取随机数生成的方法。首先随机生成p，q的位数a，然后传入随机生成的位数a，通过生成指定区间内的随机数b，并且判断这个数b是不是素数。如果是素数，那么就返回这个素数。如果不是，就继续生成随机数，直到生成的随机数是素数。

在判断素数时，我们采用了Miller-Rabin概率素性测试，其伪代码如下：

输入：奇数n≥3和安全参数t≥1

输出：对于问题“n是素数？”的回答是：“素数”或者“合数”

写$n-1=2^st$，其中t为奇整数

1. 随机选取整数$b,2\le b\le n-2$

2. 计算$r_0\equiv b^t\mod n$

3. （1）如果$r_0 =1$或者$r_0=n-1$，则通过检验，回到第一步重选b

   （2）否则有$r_0\ne 1$，以及$r_0\ne n-1$，计算$r_1\equiv r_0^2\mod n$

以此类推，直到n-2为止，通过检验则输出可能为素数，否则为合数

```python
#Robin素数判断一个数n是不是素数
def getPrime(n,a):
    t=1
    k=0
    if(getGcd(n,a)!=1):
        return 0
    else :
        q=n-1
        while(q%2==0):
           q=q>>1
           k+=1
        t=binaryExponentiation(a,q,n)
        t=t%n
        if(t==1):
            return 1
        else :
            for i in range(0,k):
                if(t==n-1):
                    return 1
                t=t*t%n
            return 0

#10次判断一个数是不是素数,确保安全性
def isPrime(n):
    cnt=10
    while(cnt>0):
        a=random.randint(2,n-2)
        if(getPrime(n,a)==0):
            return 0
        cnt=cnt-1
    return 1  
```



生成素数p和q后，由n=pq，我们就得到了需要的密钥n，接着计算n的欧拉函数。

```python
#求欧拉函数 欧拉函数值=（p-1）*（q-1）
def getEuler(prime1,prime2):
    return (prime1-1)*(prime2-1)
```



生成特定的质数e，用来产生私钥d。 

e是一个和n的欧拉函数互质的质数，我们采取指定区间内随机数生成的方法。

私钥d是逆元运算产生的，即求出e对n的欧拉函数的逆元。

为此我们采用扩展的欧几里得算法进行计算。

根据逆元的定义，若$ax\equiv 1\mod b$ ,a,b互质，则称x为a的逆元。则可以转化为$ax+by=1$。这样就可以用扩展欧几里得算法求x了。

```python
#求私钥d,扩展欧几里得求逆元
def exGcd(a,b):
    if b == 0:
        return 1, 0, a
    else:
        x,y,q=exGcd(b,a%b)
        x,y=y,(x-(a//b)*y)
        return x,y,q

def modReverse(a,p):
    x, y, q = exGcd(a,p)
    if q != 1:
        raise Exception("No solution.")  #指定位置手抛一个异常
    else:
        return (x + p) % p #防止负数
```



加解密运算，由于都涉及到幂指数取余运算，因此我们采取快速幂的办法。

```python
#快速幂求解a的q次幂对n的模
def binaryExponentiation(a,q,n):
    ans=1
    base=a
    m=n
    b=q
    while(b>0):
        if(b&1):
            ans=ans*base
            ans=ans%m
        base=base*base
        base=base%m
        b>>=1
    return ans
```



## 测试结果

主函数

```python
#主函数
if __name__ == "__main__":
    a=random.uniform(170,180)  #随机数十进制pq的位数
    p=getPQ(int(a))
    q=getPQ(int(a))
    n=p*q       #密钥n
    t=getEuler(p,q)     #pq的欧拉函数
    while(1):               #求解e
        e=random.randint(1,t)
        if(getGcd(e,t)==1):
            break
    d=modReverse(e,t)       #求解d
    print(a,"\n",e,"\n",d)
    plaintext=1548785135105485413516841  #要加密的十进制明文
    ciphertext=getCiphertext(plaintext,e,n)     #加密后的密文

    plainTruetext=getPlaintext(ciphertext,d,n)      #要解密的十进制密文
    
    print("1")
    print(plainTruetext)
```

![image-20231204110336407](https://gitee.com/jia-huaiyu/images/raw/master/202312041103475.png)